"""
Decoder file for ML Models for the Fledge Federated Learning Framework. 
Currently, development work taking place only for encoding PyTorch models with protobuf, and sending
them over a network using gRPC. 
"""
# module imports
from collections import OrderedDict

# torch imports
import torch.nn as nn
import torch.nn.functional as F
import torch.optim as optim

# Imports for layer types.
from proto.python.proto.layers.layers_pb2 import ModelLayers, Layer

class ProtoDecoder:
    """
    A decoder class, that takes in the generated byte-string from the Encoder's encode_model_layers function
    and returns a reconstructed model on the client side. 
    """
    def __init__(self, encoded_model: str) -> None:
        self.encoded_model = encoded_model
    
    def decode_model_layers(self) -> OrderedDict:
        """
        A function that decodes the encoded model byte-string, generated using protobuf.

        Returns:
            OrderedDict: Returns an ordered dictionary of the module layers involved within the model.
        """
        # initialize the layer list, parse the string
        model_layers = []
        encoded_layers = ModelLayers()
        encoded_layers.ParseFromString(self.encoded_model)
        layer_counter = 0

        # loop over the encoded layers, and create Torch Modules from them. 
        for layer in encoded_layers.layers:
            layer_counter += 1
            decoded_layer = None
            if layer.type == Layer.LayerType.LINEAR:
                in_features = layer.LinearLayer.inFeatures
                out_features = layer.LinearLayer.outFeatures
                bias = layer.LinearLayer.bias
                decoded_layer = nn.Linear(in_features, out_features, bias)
            elif layer.type == Layer.LayerType.RELU:
                inplace = layer.ReLULayer.inPlace
                decoded_layer = nn.ReLU(inplace)
            elif layer.type == Layer.LayerType.LOGSOFTMAX:
                dim = layer.LogSoftmaxLayer
                decoded_layer = nn.LogSoftmax(dim)
            else:
                print(f"Error: Encountered layer without available conversion {layer.type}. Please consult layers.proto file. Exiting.")
                exit(1)
            if decoded_layer:
                model_layers.append(decoded_layer)

        assert layer_counter == len(model_layers)
        return model_layers


